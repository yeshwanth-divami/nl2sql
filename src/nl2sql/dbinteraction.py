"""
Database Interaction Module

This module provides a standalone interface for connecting to the database
and executing SQL queries generated by the Pydantic AI agent.
Uses the schema explorer from pgsql.py for database introspection.
"""

import os
import logging
import time
from typing import Dict, List, Any, Optional, Union
from dataclasses import dataclass
from datetime import datetime
import pandas as pd
from sqlalchemy import create_engine, text
from sqlalchemy.exc import SQLAlchemyError
from dotenv import load_dotenv
from .schemas.pgsql import DbSchemaExplorer

# Load environment variables
load_dotenv()

# Global database interactor instance for reuse
_global_db_interactor = None

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)


@dataclass
class QueryExecutionResult:
    """Container for SQL query execution results."""
    success: bool
    data: Optional[pd.DataFrame] = None
    error_message: Optional[str] = None
    execution_time_ms: float = 0.0
    row_count: int = 0
    column_count: int = 0
    executed_at: Optional[datetime] = None
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert result to dictionary format."""
        result = {
            "success": self.success,
            "execution_time_ms": self.execution_time_ms,
            "row_count": self.row_count,
            "column_count": self.column_count,
            "executed_at": self.executed_at.isoformat() if self.executed_at else None
        }
        
        if self.success and self.data is not None:
            # Convert DataFrame to records format for JSON serialization
            result["data"] = self.data.to_dict(orient='records')
            result["columns"] = list(self.data.columns)
        else:
            result["data"] = None
            result["columns"] = []
            result["error_message"] = self.error_message
            
        return result


class DatabaseInteractor:
    """
    Standalone database interaction class for executing SQL queries.
    Integrates with DbSchemaExplorer for schema introspection.
    """
    
    def __init__(self, connection_string: Optional[str] = None, skip_schema_exploration: bool = False):
        """
        Initialize database interactor.
        
        Args:
            connection_string: Database connection string. If None, reads from environment.
            skip_schema_exploration: If True, skips schema exploration for faster initialization
        """
        self.connection_string = connection_string or self._build_connection_string()
        if not self.connection_string:
            raise ValueError("Database connection string could not be created. Check environment variables.")
        
        # Initialize database engine
        self.engine = create_engine(
            self.connection_string,
            pool_pre_ping=True,
            pool_recycle=3600,
            isolation_level="READ_COMMITTED"
        )
        
        # Only initialize schema explorer if not skipped (for performance)
        self.schema_explorer = None
        if not skip_schema_exploration:
            try:
                self.schema_explorer = DbSchemaExplorer(self.connection_string)
                logger.info("Database interactor initialized with schema exploration")
            except Exception as e:
                logger.warning(f"Schema exploration failed, continuing without it: {e}")
                self.schema_explorer = None
        else:
            logger.info("Database interactor initialized without schema exploration (fast mode)")
        
        logger.info("Database interactor initialized successfully")
    
    def _build_connection_string(self) -> Optional[str]:
        """
        Build database connection string from environment variables.
        
        Returns:
            Connection string or None if required variables are missing
        """
        # Check for full DATABASE_URL first
        database_url = os.getenv('DATABASE_URL')
        if database_url:
            logger.info("Using DATABASE_URL from environment")
            return database_url
        
        # Try your custom environment variable names first
        user = os.getenv('db_username')
        password = os.getenv('db_password')
        dbhost = os.getenv('db_hostname')
        dbname = os.getenv('db_database')
        
        if all([user, password, dbhost, dbname]):
            connection_string = f"postgresql://{user}:{password}@{dbhost}/{dbname}"
            logger.info("Built connection string from custom environment parameters (db_username, db_password, db_hostname, db_database)")
            return connection_string
        
        # Fallback to standard environment variable names
        db_host = os.getenv('DB_HOST') or os.getenv('DATABASE_HOST')
        db_port = os.getenv('DB_PORT') or os.getenv('DATABASE_PORT', '5432')
        db_name = os.getenv('DB_NAME') or os.getenv('DATABASE_NAME') or os.getenv('DATABASE')
        db_user = os.getenv('DB_USER') or os.getenv('DATABASE_USER') or os.getenv('USERNAME')
        db_password = os.getenv('DB_PASSWORD') or os.getenv('DATABASE_PASSWORD') or os.getenv('PASSWORD')
        
        if all([db_host, db_name, db_user, db_password]):
            connection_string = f"postgresql://{db_user}:{db_password}@{db_host}:{db_port}/{db_name}"
            logger.info("Built connection string from standard environment parameters")
            return connection_string
        else:
            missing_params = []
            if not user: missing_params.append('db_username')
            if not password: missing_params.append('db_password')
            if not dbhost: missing_params.append('db_hostname')
            if not dbname: missing_params.append('db_database')
            
            if missing_params:
                logger.error(f"Missing custom environment variables: {', '.join(missing_params)}")
            
            # Also check standard variables for comprehensive error message
            standard_missing = []
            if not db_host: standard_missing.append('DB_HOST/DATABASE_HOST')
            if not db_name: standard_missing.append('DB_NAME/DATABASE_NAME/DATABASE')
            if not db_user: standard_missing.append('DB_USER/DATABASE_USER/USERNAME')
            if not db_password: standard_missing.append('DB_PASSWORD/DATABASE_PASSWORD/PASSWORD')
            
            if standard_missing:
                logger.error(f"Missing standard environment variables: {', '.join(standard_missing)}")
            
            logger.error("Please set either custom variables (db_username, db_password, db_hostname, db_database) or standard variables for database connection")
            return None
    
    def test_connection(self) -> bool:
        """
        Test database connection.
        
        Returns:
            True if connection successful, False otherwise
        """
        try:
            with self.engine.connect() as conn:
                conn.execute(text("SELECT 1"))
            logger.info("Database connection test successful")
            return True
        except Exception as e:
            logger.error(f"Database connection test failed: {e}")
            return False
    
    def get_database_info(self) -> Dict[str, Any]:
        """
        Get database information including schema details.
        
        Returns:
            Dictionary containing database information
        """
        try:
            if self.schema_explorer:
                schema_info = self.schema_explorer.to_json()
                
                return {
                    "connection_status": "connected",
                    "database_name": schema_info.get("database", "unknown"),
                    "table_count": len(schema_info.get("tables", [])),
                    "tables": [table["name"] for table in schema_info.get("tables", [])],
                    "generated_at": schema_info.get("generated_at"),
                    "schema_details": schema_info
                }
            else:
                # Basic info without schema exploration
                return {
                    "connection_status": "connected",
                    "database_name": "available (schema exploration skipped)",
                    "table_count": "unknown",
                    "tables": [],
                    "generated_at": datetime.now().isoformat(),
                    "schema_details": None,
                    "note": "Schema exploration was skipped for performance"
                }
        except Exception as e:
            logger.error(f"Failed to get database info: {e}")
            return {
                "connection_status": "error",
                "error": str(e)
            }
    
    def get_table_schema(self, table_name: str) -> Dict[str, Any]:
        """
        Get detailed schema information for a specific table.
        
        Args:
            table_name: Name of the table
            
        Returns:
            Dictionary containing table schema details
        """
        try:
            if self.schema_explorer:
                table_info = self.schema_explorer.describe_table(table_name)
                return {
                    "success": True,
                    "table_info": table_info
                }
            else:
                return {
                    "success": False,
                    "error": "Schema exploration is disabled. Enable it for detailed table information."
                }
        except Exception as e:
            logger.error(f"Failed to get table schema for {table_name}: {e}")
            return {
                "success": False,
                "error": str(e)
            }
    
    def execute_query(self, sql_query: str, query_id: Optional[str] = None) -> QueryExecutionResult:
        """
        Execute SQL query and return results.
        
        Args:
            sql_query: SQL query to execute
            query_id: Optional identifier for the query
            
        Returns:
            QueryExecutionResult containing execution results
        """
        start_time = time.time()
        
        try:
            # Basic security validation - only allow SELECT statements
            normalized_sql = sql_query.strip().upper()
            if not normalized_sql.startswith('SELECT'):
                return QueryExecutionResult(
                    success=False,
                    error_message="Only SELECT queries are allowed",
                    execution_time_ms=(time.time() - start_time) * 1000,
                    executed_at=datetime.now()
                )
            
            # Execute query
            with self.engine.connect() as conn:
                result = conn.execute(text(sql_query))
                
                # Convert to DataFrame
                df = pd.DataFrame(result.fetchall(), columns=result.keys())
                
                execution_time = (time.time() - start_time) * 1000
                
                logger.info(f"Query executed successfully. Rows: {len(df)}, Time: {execution_time:.2f}ms")
                
                return QueryExecutionResult(
                    success=True,
                    data=df,
                    execution_time_ms=execution_time,
                    row_count=len(df),
                    column_count=len(df.columns) if not df.empty else 0,
                    executed_at=datetime.now()
                )
                
        except SQLAlchemyError as e:
            execution_time = (time.time() - start_time) * 1000
            error_msg = f"SQL execution error: {str(e)}"
            logger.error(error_msg)
            
            return QueryExecutionResult(
                success=False,
                error_message=error_msg,
                execution_time_ms=execution_time,
                executed_at=datetime.now()
            )
            
        except Exception as e:
            execution_time = (time.time() - start_time) * 1000
            error_msg = f"Unexpected error during query execution: {str(e)}"
            logger.error(error_msg)
            
            return QueryExecutionResult(
                success=False,
                error_message=error_msg,
                execution_time_ms=execution_time,
                executed_at=datetime.now()
            )
    
    def execute_multiple_queries(self, queries: List[str]) -> List[QueryExecutionResult]:
        """
        Execute multiple SQL queries.
        
        Args:
            queries: List of SQL queries to execute
            
        Returns:
            List of QueryExecutionResult objects
        """
        results = []
        for i, query in enumerate(queries):
            query_id = f"batch_query_{i+1}"
            result = self.execute_query(query, query_id)
            results.append(result)
            
            # Stop execution if a query fails
            if not result.success:
                logger.warning(f"Stopping batch execution due to failure in query {i+1}")
                break
                
        return results
    
    def get_sample_data(self, table_name: str, limit: int = 10) -> QueryExecutionResult:
        """
        Get sample data from a table.
        
        Args:
            table_name: Name of the table
            limit: Number of rows to fetch
            
        Returns:
            QueryExecutionResult containing sample data
        """
        # Basic table name validation to prevent SQL injection
        if not table_name.replace('_', '').replace('-', '').isalnum():
            return QueryExecutionResult(
                success=False,
                error_message="Invalid table name",
                executed_at=datetime.now()
            )
        
        query = f"SELECT * FROM {table_name} LIMIT {limit}"
        return self.execute_query(query, f"sample_data_{table_name}")


def create_database_interactor(skip_schema_exploration: bool = True) -> Optional[DatabaseInteractor]:
    """
    Factory function to create DatabaseInteractor from environment variables.
    
    Args:
        skip_schema_exploration: If True, skips schema exploration for faster initialization
    
    Returns:
        DatabaseInteractor instance or None if configuration is invalid
    """
    try:
        return DatabaseInteractor(skip_schema_exploration=skip_schema_exploration)
    except Exception as e:
        logger.error(f"Failed to create database interactor: {e}")
        return None


def get_global_database_interactor() -> Optional[DatabaseInteractor]:
    """
    Get or create a global database interactor instance for reuse.
    This avoids repeated initialization overhead.
    
    Returns:
        Global DatabaseInteractor instance or None if configuration is invalid
    """
    global _global_db_interactor
    
    if _global_db_interactor is None:
        logger.info("Creating global database interactor (fast mode)")
        _global_db_interactor = create_database_interactor(skip_schema_exploration=True)
        
        # Test the connection to ensure it's valid
        if _global_db_interactor and not _global_db_interactor.test_connection():
            logger.error("Global database interactor connection test failed")
            _global_db_interactor = None
            
    return _global_db_interactor


def execute_sql_query_fast(sql_query: str) -> QueryExecutionResult:
    """
    Fast SQL query execution using the global database interactor.
    
    Args:
        sql_query: SQL query to execute
        
    Returns:
        QueryExecutionResult containing execution results
    """
    interactor = get_global_database_interactor()
    
    if not interactor:
        return QueryExecutionResult(
            success=False,
            error_message="Failed to create database connection",
            execution_time_ms=0,
            executed_at=datetime.now()
        )
    
    return interactor.execute_query(sql_query)


# Example usage functions
def test_database_connection():
    """Test function to verify database connectivity."""
    interactor = create_database_interactor()
    
    if not interactor:
        print("❌ Failed to create database interactor")
        return False
    
    if interactor.test_connection():
        print("✅ Database connection successful")
        
        # Get database info
        db_info = interactor.get_database_info()
        print(f"📊 Database: {db_info.get('database_name')}")
        print(f"📋 Tables: {db_info.get('table_count')} tables found")
        
        return True
    else:
        print("❌ Database connection failed")
        return False


def execute_sample_query(query: str):
    """Execute a sample query and display results."""
    interactor = create_database_interactor()
    
    if not interactor:
        print("❌ Failed to create database interactor")
        return
    
    print(f"🔍 Executing query: {query}")
    result = interactor.execute_query(query)
    
    if result.success:
        print(f"✅ Query executed successfully")
        print(f"📊 Rows: {result.row_count}, Columns: {result.column_count}")
        print(f"⏱️ Execution time: {result.execution_time_ms:.2f}ms")
        
        if result.data is not None and not result.data.empty:
            print("\n📋 Sample results:")
            print(result.data.head())
    else:
        print(f"❌ Query failed: {result.error_message}")


if __name__ == "__main__":
    """Test the database interaction functionality."""
    print("🔧 Testing Database Interaction Module")
    print("=" * 50)
    
    # Test connection
    if test_database_connection():
        # Test sample query
        sample_query = "SELECT COUNT(*) as total_policies FROM policy"
        execute_sample_query(sample_query)
    
    print("=" * 50)
    print("✅ Database interaction module test completed")
